{"root":{"data":{"id":"ciqwixudz4w0","created":1648003616644,"text":"TAP","expandState":"expand"},"children":[{"data":{"id":"cir57i95u4g0","created":1648028110693,"text":"编译器遇到 async await 会生成一个状态机数据结构，并且使用 AsyncTaskMethodBuild.Start(ref stateMachine) 来启动状态机。","layout_mind_offset":{"x":114.99999543031089,"y":-150.83332733975539}},"children":[{"data":{"id":"cir5d3whcuw0","created":1648028549636,"text":"生成的状态机实现 IAsyncStateMachine"},"children":[{"data":{"id":"cir5e8du1x40","created":1648028637757,"text":"IAsyncStateMachine.MoveNext"},"children":[]},{"data":{"id":"cir5ehrf9hk0","created":1648028658169,"text":"IAsyncStateMachine.SetStateMaching"},"children":[]}]},{"data":{"id":"cir5fwa7d4w0","created":1648028768144,"text":"AsyncTaskMethodBuild.Start(ref stateMachine) 调用 MoveNext 来启动状态机，并且在启动状态机前记录线程的 ExecuteContext 和 SynchronizationContext， 并且在状态机结束后恢复运行前的状态。"},"children":[]},{"data":{"id":"cir5or28w200","created":1648029462056,"text":"状态机的 MoveNext() 会根据一个 int 类型的 status 字段来判断当前状态机的状态。"},"children":[]},{"data":{"id":"cir5polaxpk0","created":1648029535042,"text":"MoveNext() 会调用 Task.GetAwaiter() 来获得 Awaiter","expandState":"expand"},"children":[{"data":{"id":"cir5r5k16ts0","created":1648029650335,"text":"如果 awaiter.IsComplete == true","layout_right_offset":{"x":18,"y":80}},"children":[{"data":{"id":"cir5scn3viw0","created":1648029744123,"text":"awaiter.GetResult() 来获得结果，设置状态机状态，awaiter.SetResult() 来设置结果并返回。"},"children":[]}]},{"data":{"id":"cirw6trr7zk0","created":1648104227365,"text":"在调用 GetAwaiter() 之前的代码，就是在异步方法中，但是是在 Task.Run() 之前的代码，这里的代码是同步执行的。","layout_right_offset":{"x":16,"y":-47}},"children":[{"data":{"id":"cirw7y6qxzk0","created":1648104315343,"text":" 所以异步方法可以包含少量的同步操作，要尽量少，可以用来做入参判断等。太多的话，并且程序是运行在 UI 线程下，那么就会阻塞 UI 线程。"},"children":[]}]},{"data":{"id":"cir5s1c4y0w0","created":1648029719515,"text":"如果 awaiter.IsComplete == false"},"children":[{"data":{"id":"cir5tnhj76o0","created":1648029846094,"text":"调用 AsyncTaskMethodBuilder.AwaitUnsafeCompleted(ref awaiter, ref stateMachine) "},"children":[{"data":{"id":"cir5whck8140","created":1648030067826,"text":" 这个方法会调用 ThreadPool.UnsafeQueueWorkItemInternal(object callBack, bool perferLocal) 来执行异步方法","layout_right_offset":{"x":-1.6666666004393846,"y":-3.333333200878542}},"children":[{"data":{"id":"cir5yw0pxcw0","created":1648030256490,"text":"这说明了 c# 中的异步是基于线程池来执行的"},"children":[]},{"data":{"id":"cir5zfrbe2g0","created":1648030299457,"text":"根据 perferLocal，也可以将异步方法独立于线程池执行。"},"children":[]}]},{"data":{"id":"cir64mj1to00","created":1648030706015,"text":"这个方法还会生成一个委托，在执行完异步方法，执行一个 ContinueTask 来再次调用 MoveNext"},"children":[{"data":{"id":"cir65sdjqtk0","created":1648030797107,"text":"再次调用 MoveNext 的时候，就会执行异步方法之后的代码，并且使用 awaiter.GetResult() 来或者异步结果，只用 await.SetResult() 来设置异步结果。"},"children":[]},{"data":{"id":"cir66ryq7zs0","created":1648030874575,"text":"如果在没有 SynchronousContext 的情况下，会使用 TaskScheduler 来调用 MoveNext 委托，这样异步方法之后的代码就会跟异步方法同一个线程了。"},"children":[]},{"data":{"id":"cir68bd9zso0","created":1648030995178,"text":"如果有 SynchronousContext 的情况下，会调用 Synchronous.Post(Action action) 来将异步方法之后的代码放到同步上下文指定的线程中"},"children":[{"data":{"id":"cir6a0tzrvc0","created":1648031128973,"text":"WPF Winform ASP 就有 SynchronousContext， 控制台程序则没有"},"children":[]},{"data":{"id":"cir6al2wubs0","created":1648031173047,"text":"可以通过配置 Task.ConfigureAwait(false) 来指定不会返回 SynchronouseContext 的线程中"},"children":[]},{"data":{"id":"cirw96awi000","created":1648104411372,"text":"所以，异步方法中，也可能引起 UI 线程的阻塞或者死锁， SynchronousContext 会重新切换回 UI 线程。"},"children":[]}]}]}]}]},{"data":{"id":"cir5s322s9k0","created":1648029723260,"text":"MoveNext 一般会执行两次，如果 Task 有缓存的话，就执行一次"},"children":[{"data":{"id":"cir6cnwub3c0","created":1648031335939,"text":"所以一般执行 Task.Run 会切换线程。"},"children":[]},{"data":{"id":"cir6czy5y740","created":1648031362141,"text":"如果 Task 因为有缓存立刻返回，则不会切换线程"},"children":[{"data":{"id":"cir6d7zjwi80","created":1648031379639,"text":"在这种情况下，每次都会生成一个没必要的 Task，如果想提高性能，可以使用 ValueTask 来替换 Task。"},"children":[]}]}]}]}]},{"data":{"id":"cir6e00svs00","created":1648031440664,"text":"Task 线程分析","layout_mind_offset":{"x":254.83330722318885,"y":-327.0833293079505}},"children":[{"data":{"id":"cir6f9kvh400","created":1648031539833,"text":"单个 Task 线程分析"},"children":[]},{"data":{"id":"cir6feq7adk0","created":1648031551039,"text":"连续多个 Task 线程分析"},"children":[]},{"data":{"id":"cir6fk92g2w0","created":1648031563064,"text":"嵌套 Task 线程分析"},"children":[]}]},{"data":{"id":"cirvz33ewko0","created":1648103620748,"text":"ThreadPool"},"children":[{"data":{"id":"cirzw3gi7nk0","created":1648114670886,"text":"CLR 的线程池是基于异步 IO 实现的，也就是说，线程如果没有执行操作，而是在等待，那么线程会回到线程齿，等到等待完毕，计算机系统通知 IO 结束，再从线程池取出线程，执行后续操作。"},"children":[]},{"data":{"id":"cirzxeweu2w0","created":1648114774157,"text":"Task 就是基于线程池实现的，那么如果 Task.Run(action) , action 中间存在等待很久的情况，如请求返回很久的接口，或者是加载一个很大的文件，那么线程会先回到线程池，等到 IO 结束，再从线程池拿一条线程执行后续操作。"},"children":[{"data":{"id":"cirzyr3t5zs0","created":1648114879090,"text":"可以在 Task.Run() 中 使用 Task.Delay() 等待20秒，可以该行代码前后的线程是不一致的。"},"children":[]}]}]},{"data":{"id":"cirvz6jredk0","created":1648103628266,"text":"BackWorker"},"children":[]},{"data":{"id":"cirvzf17gqg0","created":1648103646736,"text":"PLINQ"},"children":[]},{"data":{"id":"ciry9d83hjk0","created":1648110068660,"text":"Exception","layout_mind_offset":{"x":-242,"y":97}},"children":[{"data":{"id":"cirygibtibs0","created":1648110628318,"text":"异步方法返回异常的方式","layout_left_offset":{"x":0,"y":-1}},"children":[{"data":{"id":"ciryh17z1hk0","created":1648110669444,"text":"throw Exception() "},"children":[{"data":{"id":"ciryid484g00","created":1648110773703,"text":"当是调用异步方法的方式出错了，那么应该直接 throw 异常，因为调用出错是可控的，是人为的，不应该出现在生产中的。throw 一般用来抛出参数异常，如 null 异常， 0 异常。","layout_left_offset":{"x":-3,"y":1}},"children":[]}]},{"data":{"id":"ciryhtdt5080","created":1648110730747,"text":"Task.FromException<>() 或 Task.FromException()"},"children":[{"data":{"id":"ciryk0vh8q00","created":1648110903781,"text":"如果是异步方法执行过程中出错了，如下载的时候网络断了，这种异常无法预测，应该直接使用 Task.FromException，返回一个异常结果。"},"children":[]}]}]},{"data":{"id":"ciryuv9llls0","created":1648111753580,"text":"异步方法中返回异常的位置"},"children":[{"data":{"id":"ciryv0brwko0","created":1648111764596,"text":"在 Task.Run() 中"},"children":[{"data":{"id":"ciryw7euofc0","created":1648111858384,"text":"在这个位置，如果调用方没有处理异常，无论是 throw 还是 FromException 都不会中断程序。"},"children":[]}]},{"data":{"id":"ciryvzanotc0","created":1648111840716,"text":"在 Task.Run() 外"},"children":[{"data":{"id":"cirywuflni80","created":1648111908495,"text":"在这个位置，如果调用方没有处理异常，那么 throw exception 会中断程序，而 FromException 则不会。"},"children":[]}]}]},{"data":{"id":"cirygrdqpjk0","created":1648110648025,"text":"捕获异步方法异常的方式"},"children":[{"data":{"id":"cirylzrvnjk0","created":1648111058115,"text":"使用 await 等待异步方法，并且使用 try catch 包装代码块。"},"children":[{"data":{"id":"cirypikyxog0","created":1648111334149,"text":"为了异步方法更符合同步方法的使用逻辑，所以设计者在这种情况下，会返回具体的异常类型，而不是聚合类型。"},"children":[{"data":{"id":"ciryr1uiakw0","created":1648111454449,"text":"特殊情况就是，Task.WaitAll 会返回聚合类型。"},"children":[]}]}]},{"data":{"id":"cirym5s6g680","created":1648111071194,"text":"使用 ContinueWith() 等待异步方法"},"children":[{"data":{"id":"ciryri416t40","created":1648111489853,"text":"如果异常是 FromException，这种情况下会 Task.IsFaulted = true, Task.Exception = AggregateException"},"children":[]},{"data":{"id":"cirzj51t9i80","created":1648113655617,"text":"如果异常是 throw 出来的，会直接中断程序"},"children":[]}]},{"data":{"id":"cirymobgfqo0","created":1648111111542,"text":"只调用异步方法，但是不对 Task 的返回值做任何操作。"},"children":[{"data":{"id":"ciryt1ztxk00","created":1648111611499,"text":"这种情况下，如果异常是 throw 出来的，那么会中断程序，如果是 Task.FromException 的方式，则不会中断程序。"},"children":[]}]}]},{"data":{"id":"cirynxkrpc80","created":1648111210060,"text":"返回异常的种类"},"children":[{"data":{"id":"cirypl5c42g0","created":1648111339734,"text":"具体的异常类型，如 ArgumentNullException"},"children":[]},{"data":{"id":"cirypuyzrt40","created":1648111361118,"text":"聚合异常类型，AggregateException"},"children":[]}]}]},{"data":{"id":"cis04rdal2g0","created":1648115349848,"text":"命名规则，参数，返回值"},"children":[]},{"data":{"id":"cis04w5b4iw0","created":1648115360249,"text":"如何正确地初始化异步方法"},"children":[]}]},"template":"default","theme":"classic","version":"1.4.43"}