{"root":{"data":{"id":"cjyhjq3jmgg0","created":1652429999593,"text":"中心主题","expandState":"expand"},"children":[{"data":{"id":"cjyhk1jdwww0","created":1652430024495,"text":"两种托管模型","expandState":"expand","layout":null},"children":[{"data":{"id":"cjyhkijoh9c0","created":1652430061518,"text":"Blazor Server","expandState":"expand","layout":null},"children":[]},{"data":{"id":"cjyhklxe68w0","created":1652430068878,"text":"Blazor WebAssembly","expandState":"expand","layout":null},"children":[]}]},{"data":{"id":"cjyhlrhcqhs0","created":1652430159333,"text":"Razor 标记","layout":null},"children":[{"data":{"id":"cjyhlxowkcg0","created":1652430172850,"text":"@page 指令","layout":null},"children":[{"data":{"id":"cjyhmfgrwkg0","created":1652430211541,"text":"用于路由","layout":null},"children":[]}]},{"data":{"id":"cjyhm0nvja80","created":1652430179318,"text":"@code 指令","layout":null},"children":[{"data":{"id":"cjyhmj84vps0","created":1652430219725,"text":"用于包含 c# 代码块","layout":null},"children":[]}]},{"data":{"id":"cjyhm2hmvaw0","created":1652430183295,"text":"成员访问指令","layout":null},"children":[{"data":{"id":"cjyhmq9niyg0","created":1652430235055,"text":"用于在 html 中访问 c# 代码块的成员","layout":null},"children":[]}]},{"data":{"id":"cjyhwo0rlq80","created":1652431013805,"text":"@using","layout":null},"children":[{"data":{"id":"cjyhwsaxwaw0","created":1652431023128,"text":"引入命名空间","layout":null},"children":[]}]},{"data":{"id":"cjyhwpm4yso0","created":1652431017274,"text":"@inject","layout":null},"children":[{"data":{"id":"cjyhwyait5k0","created":1652431036163,"text":"注入容器中的服务","layout":null},"children":[]}]},{"data":{"id":"ck2hr7klvgg0","created":1652836826006,"text":"@implements"},"children":[]},{"data":{"id":"cjyhydaa6zk0","created":1652431147165,"text":"@if @switch","layout":null},"children":[]},{"data":{"id":"cjyhyedt4gg0","created":1652431149555,"text":"@foreach @do @while @for","layout":null},"children":[]},{"data":{"id":"cjyjryqm0dk0","created":1652436287535,"text":"@bind","layout":null},"children":[{"data":{"id":"cjyjs1b7mc00","created":1652436293134,"text":"数据绑定","layout":null},"children":[]}]},{"data":{"id":"cjyjse06s540","created":1652436320766,"text":"@bind-value @bind-value:event","layout":null},"children":[{"data":{"id":"cjyjsm8872o0","created":1652436338666,"text":"实现文本框输入立刻更新数据","layout":null},"children":[]}]},{"data":{"id":"cjyjsyhruw80","created":1652436365365,"text":"@bind:format","layout":null},"children":[{"data":{"id":"cjyjt21a4kg0","created":1652436373075,"text":"格式化绑定数据","layout":null},"children":[]}]}]},{"data":{"id":"cjyisk469600","created":1652433512958,"text":"组件状态","expandState":"expand","layout":null},"children":[{"data":{"id":"cjyj6zgdkm80","created":1652434643445,"text":"直接给子组件传参","expandState":"expand","layout":null},"children":[{"data":{"id":"cjyifir4wxs0","created":1652432491258,"text":"[Parameter]","layout":null},"children":[]}]},{"data":{"id":"cjyj79t45zs0","created":1652434665984,"text":"给嵌套深的组件传参","expandState":"expand","layout":null},"children":[{"data":{"id":"cjyistloons0","created":1652433533607,"text":"<CascadingValue  Name=\"\" Value=\"\" />标记","layout":null},"children":[]},{"data":{"id":"cjyj7ix0uow0","created":1652434685811,"text":"使用 [CascadingParameter(Name=\"\")]  特性来修饰组件成员，从而来访问值","layout":null},"children":[]}]},{"data":{"id":"cjyjgs3kgeg0","created":1652435411075,"text":"在容器中注册状态类来实现状态共享","layout":null},"children":[]}]},{"data":{"id":"ck0sxd4zl8w0","created":1652665220603,"text":"路由","layout":null},"children":[{"data":{"id":"ck0sxm6dnvk0","created":1652665240278,"text":"路由模板","layout":null},"children":[{"data":{"id":"ck0t0x3goco0","created":1652665499139,"text":"<Router />","layout":null},"children":[]},{"data":{"id":"ck0t13947ww0","created":1652665512541,"text":"<Found />","layout":null},"children":[]},{"data":{"id":"ck0t162256g0","created":1652665518645,"text":"<NotFound />","layout":null},"children":[]},{"data":{"id":"ck0t1avobhc0","created":1652665529143,"text":"RouteView />","layout":null},"children":[]}]},{"data":{"id":"ck0taidpz4w0","created":1652666250749,"text":"@page 指令","expandState":"expand","layout":null},"children":[{"data":{"id":"ck0tban0d5k0","created":1652666312260,"text":"用于组件路由","layout":null},"children":[]},{"data":{"id":"ck0tbf1uewo0","created":1652666321864,"text":"一个组件可以配置多个路由","layout":null},"children":[]},{"data":{"id":"ck0vdf9c4hk0","created":1652672121266,"text":"路由参数","expandState":"expand","layout":null},"children":[{"data":{"id":"ck0v98mzjow0","created":1652671793397,"text":"@page \"path/{param?}\" 可选路由参数","layout":null},"children":[]},{"data":{"id":"ck0v9txnzkw0","created":1652671839755,"text":"@page \"path/{param}\" 必选路由参数","layout":null},"children":[]},{"data":{"id":"ck0vdr20to80","created":1652672146945,"text":"@page \"path/{param:int}\" 路由参数类型","layout":null},"children":[]},{"data":{"id":"ck0ve2gcmqo0","created":1652672171756,"text":"@page \"path/{*param}\"  捕获全部路由参数","layout":null},"children":[]}]}]},{"data":{"id":"ck0tbmkewa80","created":1652666338225,"text":"@inject NavigationManager","layout":null},"children":[]},{"data":{"id":"ck0tg0vnbyo0","created":1652666682836,"text":"< NavLink/>","layout":null},"children":[]}]},{"data":{"id":"ck0yr0ez86g0","created":1652681649383,"text":"Blazor Layout","layout":null},"children":[{"data":{"id":"ck0yr4w8aeo0","created":1652681659133,"text":"用于复用UI界面","layout":null},"children":[]},{"data":{"id":"ck0yrgzzksg0","created":1652681685482,"text":"有两个要求，：\n1. 继承 LayoutComponentBase \n@inherits LayoutComponentBase\n2. 必须包含 @body","layout":null},"children":[]},{"data":{"id":"ck0ysb6j9w00","created":1652681751181,"text":"使用 Layout","layout":null},"children":[{"data":{"id":"ck0yske1umw0","created":1652681771227,"text":"通过 @layout 引入布局","layout":null},"children":[]},{"data":{"id":"ck0ysvcgfww0","created":1652681795075,"text":"命名为 _Imports.razor 可以自用应用到文件夹及其所有子文件夹中的组件，不可用于根目录。","layout":null},"children":[]},{"data":{"id":"ck0yudzf39k0","created":1652681914010,"text":"应用到全局，在 App.razor 的 RouteView 配置 DefaultLayout 属性。","layout":null},"children":[]}]}]},{"data":{"id":"ck1x1ik1p740","created":1652778390250,"text":"Blazor 类库","layout":null},"children":[]},{"data":{"id":"ck0zdjgo3jk0","created":1652683414856,"text":"事件","layout":null},"children":[{"data":{"id":"ck0zdwdqayw0","created":1652683442976,"text":"使用 【@DOM事件名称】来捕获 DOM 事件，可以直接绑定到 c# 方法，也可以使用 lambda 表达式。","layout":null},"children":[]},{"data":{"id":"ck0zfexa2yo0","created":1652683561704,"text":"跟 JS 处理事件的区别：\n1. JS 不需要添加 @ 符号，blazor 需要。\n2. JS 需要完整的方法，也就是需要 方法名()，Blazor 不需要。\n3. JS 是在客户端处理事件，Blazor 是在服务端处理事件，然后将结果返回客户端。所以一些实时性很强的事件，不适合用 Blazor 处理，如 onmousemove。","layout":null},"children":[]},{"data":{"id":"ck0zh8yuha00","created":1652683705467,"text":"事件处理程序应该是异步的。","layout":null},"children":[]},{"data":{"id":"ck0zhlbsfaw0","created":1652683732371,"text":"使用事件设置焦点","layout":null},"children":[{"data":{"id":"ck10c30ccf40","created":1652686121786,"text":"@ref ","layout":null},"children":[]},{"data":{"id":"ck10c72huyw0","created":1652686130623,"text":"ElementReference 引用一个 DOM 元素","layout":null},"children":[]},{"data":{"id":"ck10cdcw86g0","created":1652686144312,"text":"ElementReference.FocusAsync()","layout":null},"children":[]}]},{"data":{"id":"ck10d38k0jc0","created":1652686200646,"text":"替换事件的默认操作\n@事件：preventDefault","layout":null},"children":[]},{"data":{"id":"ck10dcrnh4g0","created":1652686221392,"text":"跨组件处理事件\n声明属性 EventCallBack<T>","layout":null},"children":[]}]},{"data":{"id":"ck10qaswvew0","created":1652687235849,"text":"Blazor 表单","layout":null},"children":[{"data":{"id":"ck10qi2w10g0","created":1652687251690,"text":"<EditFrom />","layout_right_offset":{"x":354,"y":-49},"layout":null},"children":[{"data":{"id":"ck10r58o9rk0","created":1652687302105,"text":"支持绑定到 Model","layout_right_offset":{"x":336,"y":-145},"layout":null},"children":[]},{"data":{"id":"ck10rt9038g0","created":1652687354368,"text":"支持三种提交后事件\nOnValidSubmit\nOnInvalidSubmit\nOnSubmit","layout":null},"children":[]},{"data":{"id":"ck10swgf6w00","created":1652687439711,"text":"支持属性验证","expandState":"expand","layout":null},"children":[{"data":{"id":"ck113gv9zds0","created":1652688267787,"text":"声明式验证","expandState":"expand","layout":null},"children":[{"data":{"id":"ck111vn8yyw0","created":1652688143225,"text":"验证消息显示组件\n<DataAnnotationsValidator />\n<ValidationSummary />\n<ValidationMessage />","layout":null},"children":[]},{"data":{"id":"ck113pus5wo0","created":1652688287348,"text":"属性特性\n[Required]\n[EmailAddress]\n[Range]\n[ValidationNever]\n[CreditCard]\n[Compare]\n[Phone]\n[RegularExpression]\n[StringLength]\n[Url]","layout":null},"children":[]},{"data":{"id":"ck1153zpvcg0","created":1652688396485,"text":"自定义验证特性\n继承 ValidationAttribute","layout":null},"children":[]},{"data":{"id":"ck11bequvao0","created":1652688890079,"text":"属性更改后验证","layout":null},"children":[{"data":{"id":"ck11bk9lykw0","created":1652688902097,"text":"给 EditForm 绑定 EditContext，并处理 OnFieldChanged 事件","layout":null},"children":[]},{"data":{"id":"ck11cir3sx40","created":1652688977166,"text":"需要在实现  IDisposable，并且在实现中释放事件","layout":null},"children":[]}]}]},{"data":{"id":"ck116b8wy7k0","created":1652688490643,"text":"编程式验证","layout":null},"children":[{"data":{"id":"ck116iwa2bs0","created":1652688507293,"text":"通过三个提交后事件来验证属性","layout":null},"children":[]}]}]},{"data":{"id":"ck10t5k7ue80","created":1652687459532,"text":"支持多种输入控件\nInputCheckbx\nInputDate<TValue>\nInputFile\nInputNumber<TValue>\nInputRadio<TValue>\nInputRadioGroup<TValue>\nInputRadioGroup<TValue>\nInputSelect<TValue>\nInputText\nInputTextArea","layout":null},"children":[]}]}]},{"data":{"id":"ck124feppoo0","created":1652691164083,"text":"互操作","layout":null},"children":[{"data":{"id":"ck1vvqbanfk0","created":1652775115840,"text":"在 Blazor 中加载 JS 代码","expandState":"expand","layout":null},"children":[{"data":{"id":"ck1vxb9udc00","created":1652775239829,"text":"Blazor 只能处理 body 元素内的内容，所以 js 脚本应该放到 body 内的最末尾，并且 在 _framework/blazor.serve.js 之后","layout":null},"children":[]},{"data":{"id":"ck1vyqawvlk0","created":1652775350910,"text":"也可以根据环境的不同，动态加载不同的脚本，利用 window.loadscript","layout":null},"children":[]},{"data":{"id":"ck1vz8mwlyw0","created":1652775390817,"text":"JS 脚本应该放在 Blazor 应用中的 wwwroot/js 文件夹下","layout":null},"children":[]},{"data":{"id":"ck1w0ndrp9s0","created":1652775501280,"text":"通过 nuget 将 js 库加载到 wwwroot/js 下","layout":null},"children":[]}]},{"data":{"id":"ck1w1b7lvu80","created":1652775553150,"text":"从 .net 调用 js","layout":null},"children":[{"data":{"id":"ck1w1k6hcuo0","created":1652775572673,"text":"注入服务 @inject IJSRunting JS ","layout":null},"children":[]},{"data":{"id":"ck1w20l8ans0","created":1652775608394,"text":"调用 await JS.InvokeVoidAsync(\"方法名\", \"参数\")","layout":null},"children":[]},{"data":{"id":"ck1w2j3xt8w0","created":1652775648707,"text":"提供了两个方法， InvokeAsync 和 InvokeVoidAsync，参数必须可以序列化成 json。","layout":null},"children":[]},{"data":{"id":"ck1w5tde68w0","created":1652775906139,"text":"如果js库需要传递 UI 元素，应该使用 ElementReference 引用一个 空白的 div 并传递过去，因为Blazor 不会处理空白的 div，而直接操作 UI 元素，会破坏 Blazor 视图。","layout":null},"children":[]},{"data":{"id":"ck1wczphrko0","created":1652776468481,"text":"JS 在客户端执行，Blazor 在服务端执行，所以互操作时，可能会有网络问题导致失败，所以默认一分钟不成功就算失败。\n1. 可以在全局修改时间间隔 \nbuilder.Services.AddServerSideBlazor(options => options.JSInteropDefaultCallTimeout = TimeSpan.FromSeconds(120));\n2. 在调用 InvokeAsync() 调用重载传参。","layout":null},"children":[]}]},{"data":{"id":"ck1wk59d7kw0","created":1652777029115,"text":"从 js 调用 .net","layout":null},"children":[{"data":{"id":"ck1wk9fv2ow0","created":1652777038215,"text":"调用静态方法","layout":null},"children":[{"data":{"id":"ck1wrvx78bs0","created":1652777635702,"text":"DotNet.invokeMethodAsync(\"程序集\",\"方法名\")","layout":null},"children":[]}]},{"data":{"id":"ck1wsflvkio0","created":1652777678553,"text":"调用实例方法","layout":null},"children":[{"data":{"id":"ck1wsj5ln8o0","created":1652777686276,"text":"var objectRef;\nwindow.populateObjectRef = (ref) => {\n  objectRef = ref;\n}\nawait objectRef.invokeMethodAsync(\"方法名\")","layout":null},"children":[]}]}]}]},{"data":{"id":"ck1tg94ugj40","created":1652768260763,"text":"生命周期","layout":null},"children":[{"data":{"id":"ck1tgchzb7c0","created":1652768268087,"text":" ","image":"https://docs.microsoft.com/zh-cn/learn/aspnetcore/blazor-build-rich-interactive-components/media/4-component-lifecycle.png","imageTitle":"事件","imageSize":{"width":200,"height":172},"layout_right_offset":{"x":591.2499911896887,"y":-162.4999975785613},"layout":null},"children":[]},{"data":{"id":"ck1th0rtxl40","created":1652768320926,"text":"所有组件的父类都是 ComponentBase，所以可以通过重写对应的方法，从而在生命周期内进行操作。","layout_right_offset":{"x":818.7499877996744,"y":-97.49999854713678},"layout":null},"children":[]},{"data":{"id":"ck1tjey8teo0","created":1652768508517,"text":"SetParametersAsync(ParameterView) \n1. 在默认构造函数之后调用，可以重写来进行操作。如果没有设置参数也会调用。\n2. 如果参数修改了，会再次调用。","layout_right_offset":{"x":541.2499919347466,"y":-21.249999683350325},"layout":null},"children":[]},{"data":{"id":"ck1tjrp7ok00","created":1652768536269,"text":"OnInitialized() OnInitializedAsync()\n1. 在 SetParametersAsync 之后运行。\n2. 在 Server 模式下，指挥调用一次。\n3. 在 ServerPrendered 模式下，会调用两次。一次是预呈现状态，一次是跟 SignR 建立连接时。","layout_right_offset":{"x":454.99999321997177,"y":62.499999068677425},"layout":null},"children":[]},{"data":{"id":"ck1u6flhxp40","created":1652770312298,"text":"OnParametersSet() OnParametersSetAsync()\n1. 如果是第一次呈现组件，在 OnInitialized 或 OnInitializedAsync 之后运行。\n2. 否则在 SetParametersAsync 之后运行。","layout":null},"children":[]},{"data":{"id":"ck1ub4guoo80","created":1652770679894,"text":"OnAfterRender(bool) OnAfterRenderAsync(bool)\n1. 当需要更新界面时，就会调用这个方法。\n2. 可以在 ShouldRender 返回 false 从而阻止渲染。\n3. 接收一个bool 参数，表明是不是首次渲染。\n4. 可以在这个方法中执行 JS 互操作。","layout":null},"children":[]},{"data":{"id":"ck1uhluh5jc0","created":1652771187908,"text":"Dispose 和 DisposeAsync\n1. Blazor 也可以使用托管和非托管资源，如果使用了非托管资源，应该手动释放。\n2. @implements IDisposeable 来实现接口。","layout":null},"children":[]}]},{"data":{"id":"ck1vpdnpvw00","created":1652774618108,"text":"通过 RenderFragment 创建模板","layout":null},"children":[{"data":{"id":"ck1vpujgp000","created":1652774654856,"text":"Blazor 有两种方式来实现界面复用，\n一种是 Blazor Layout，一种是  RenderFragment。","layout":null},"children":[]},{"data":{"id":"ck1vqygfqy80","created":1652774741745,"text":"Render Fragment 可以直接复用一个HTML 片段","layout":null},"children":[]},{"data":{"id":"ck1vrfexv8o0","created":1652774778659,"text":"Render Fragment 默认的子属性是 ChildContent，可以自己命名，但是赋值的时候就必须显示赋值。","layout":null},"children":[]},{"data":{"id":"ck1vsejs6mg0","created":1652774855140,"text":"RenderFrament 支持泛型，\n使用@typeparam T 来声明泛型。","layout":null},"children":[]}]}]},"template":"default","theme":"classic","version":"1.4.43"}